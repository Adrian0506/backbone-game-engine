<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Backbone Game Engine</title>
    <meta name="description" content="Elementary HTML5 Canvas Game Engine based on Backbone.">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href="favicon.ico" rel="shortcut icon" type="image/x-icon" />
    <link href="apple_touch_icon.png" rel="apple-touch-icon" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
    <script src="docs/jquery.min.js" type="text/javascript"></script>
    <script src="docs/bootstrap.min.js" type="text/javascript"></script>
    <link href="docs/bootstrap.min.css" rel="stylesheet" type="text/css" charset="utf-8">

    <link href="docs/docs.css" rel="stylesheet" type="text/css" charset="utf-8">
  </head>

  <body data-spy="scroll" data-target="#sidebar" data-offset="100">
    <header class="navbar navbar-inverse" role="banner">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle pull-left" data-toggle="collapse" data-target="#navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html" title="Elementary HTML5 Canvas Game Engine based on Backbone."><img src="apple_touch_icon.png" /> Backbone Game Engine</a>
      </div>
      <div id="navbar-collapse" class="collapse navbar-collapse" role="navigation">
        <ul class="nav navbar-nav">
          <li><a href="index.html">Documentation</a></li>
          <li><a href="examples.html">Examples</a></li>
        </ul>
        <ul class="nav navbar-nav navbar-right">
          <li class="github-icon"><a href="https://github.com/martindrapeau/backbone-game-engine" title="Fork me on Github"><img src="docs/github.png" />Github</a></li>
        </ul>
      </div>
    </header>

    <div class="container">
    <div class="row">

    <div class="col-md-9">
      <div id="introduction" class="row">
        <div class="col-md-12">
          <h1>HTML5 Canvas &amp; Backbone</h1>
        </div>
      </div>
      <div class="row">
        <div class="col-md-6 col-xs-6">
          <p>
            An elementary HTML5 Canvas game engine built on Backbone. Examples:
          </p>
          <ul>
            <li>Elementary: <a href="ball/index.html" target="_blank">Bouncing ball</a></li>  
            <li>Basic: <a href="mario/index.html" target="_blank">Mario in an empty world</a></li>       
            <li>Advanced: <a href="super-mario-bros/index.html" target="_blank">Super Mario Bros, level 1-1</a></li>
          </ul>
          <p>
            These examples are on <a href="https://github.com/martindrapeau/backbone-game-engine">Github</a>.
          </p>
        </div>
        <div class="col-md-3 col-xs-6">
          <p>
            <a href="super-mario-bros/index.html" target="_blank">
              <img src="docs/super-mario-bros-level-1-1.png" class="img-responsive" alt="Super Mario Bros level 1-1" title="Super Mario Bros level 1-1" />
            </a>
          </p>
        </div>
      </div>

      <div id="features" class="row">
        <div class="col-md-12">
          <h3>Features:</h3>
          <ul>
            <li><strong>Built on Backbone</strong>. Events, models, collections, inheritance and RESTful persistence. Why reinvent the wheel?</li>
            <li><strong>HTML5 canvas only</strong>. No jQuery, as little DOM manipulations as possible.</li>
            <li><strong>No compilation</strong>. You don't need to install node, grunt or whatever else. Just code and press F5 to run.</li>
            <li><strong>No server required</strong>. Fork this repo and your Github site is up and going. Create your own game and point your friends to it. Rebase to pull in latest engine updates.</li>
            <li><strong>Built for mobile</strong>. Conceived to run on tablets. Share your URL with Mom so she can add it to the home screen of her iPad.</li>
            <li><strong>Take if offline</strong>. With HTML5 Application Cache, your game runs offline. Perfect for taking it on the road or on a fishing trip.</li>
            <li><strong>Save state</strong>. With HTML5 Local Storage, save where you are.</li>
            <li><strong>World editor</strong>. Conceived for tile-based games, comes with a world editor. Place your tiles and characters, then hit play to try it out. Hit save to save your world.</li>
          </ul>

        </div>
      </div>

      <div id="dependencies" class="row">
        <div class="col-md-12">
          <h3>Dependencies</h3>
          <ul>
            <li><a href="http://underscorejs.org/" target="_blank">Underscore</a> </li>
            <li><a href="http://backbonejs.org/" target="_blank">Backbone</a> </li>
            <li><a href="https://github.com/inkling/backbone.native/" target="_blank">backbone.native</a>. To drop jQuery.</li>
            <li><a href="http://eightmedia.github.io/hammer.js/" target="_blank">hammer.js</a>. To handle touch events.</li>
          </ul>
          <p>
            All included in the <code>3rd</code> folder.  That and nothing else.
          </p>

          <h3>Why Backbone?</h3>
          <p>
            Backbone implements <a href="http://backbonejs.org/#Events" target="_blank">events</a>, <a href="http://backbonejs.org/#Model" target="_blank">models</a>, <a href="http://backbonejs.org/#Collection" target="_blank">collections</a>, <a href="http://backbonejs.org/#Model-extend" target="_blank">inheritance</a> and <a href="http://backbonejs.org/#Sync" target="_blank">persistence</a>. Models implement getters and setters for object attributes. Models and Collections have an <code>extend</code> function to easily do inheritance. They implement methods for persistence (RESTful JSON by default). They can also trigger events and bind to them. Everything you need to build a great extensible game engine. Plus, Backbone is now widely used and provides these features in a standard fashion with a huge community to support them. I hope this project can make game programming accessible to developers already familiar with Backbone.
          </p>

          <h3>Using and Contributing</h3>
          <p>
            Backbone Game Engine was built to get you going fast. <a href="https://github.com/martindrapeau/backbone-game-engine">Fork this repository</a>, and your own Github page will be ready in minutes. You can then create your own games by simply creating a new directory, and putting files in it.
          </p>
          <p>
            The default branch is <code>gh-pages</code> so that any changes get published automatically to the Github page. Changes typically take only a few seconds to get published. This allows you to develop, test, document and deploy rapidly. It is a double-edge sword though. Any untested code you push to your fork on that branch will be felt by your users. It is therefore a good practice to create and work on another branch, and fast-forward merge to the <code>gh-pages</code> branch when done.
          </p>
          <p>
            To report a bug, use <a href="https://github.com/martindrapeau/backbone-game-engine/issues" target="_blank">Github issues</a>. To contribute improvements, bug fixes or new examples, make changes to your fork and do a pull request.
          </p>
          <br/>
        </div>
      </div>

      <!-- Documentation -->
      <div id="getting-started" class="row">
        <div class="col-md-12">
          <h1>Getting Started</h1>
        </div>
      </div>

      <div id="documentation-Backbone" class="row">
        <div class="col-md-12">
          <h3>Backbone</h3>
          <p>
            The engine is based on Backbone so it is essential to understand its core structure: a <a href="http://backbonejs.org/#Model" target="_blank">Backbone.Model</a>. A model has hash of <code>attributes</code> that are changed via getter and setter methods <code>get</code> and <code>set</code>. These attributes should only contain state information as it is those attributes which get saved and restored. A model is a Javascript object. Hence behaviour can be stored as properties and methods directly on the object. For example a sprite sheet points to an image. Attribute <code>img</code> contains the DOM selector (by id) for retrieving the Image object. Property <code>img</code> contains reference to the Image object. It is automatically set when the sprite sheet model is initialized.
            <pre>
var spriteSheet = new Backbone.SpriteSheet({
  id: "mario",
  img: "#mario",
  tileWidth: 32,
  tileHeight: 64,
  tileColumns: 21,
  tileRows: 6
});
spriteSheet.get("img"); // attribute
// #mario

spriteSheet.img; // property
// &lt;img id=​"mario" src=​"../​super-mario-bros/​super-mario-2x.png" style=​"display:​none;​"&gt;

spriteSheet.img.width
//672

spriteSheet.img.height
//384
</pre>
          </p>
          <p>
            In fact, a model stores its attributes in the object property <code>attributes</code>. Methods <code>get</code>, <code>set</code> and <code>toJSON</code> operate on that property. Just remember that state date like sprite coordinates, velocity, etc go in there. However references to other objects do not.
          </p>
          <div class="alert alert-info">
            Note on nomenclature: I use the word <strong>attribute</strong> to define state data (get and set stored in obejct property attributes) while we I the word <strong>property</strong> to define behavioural data stored directly on the object.
          </div>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h3 id="documentation-no-jQuery">Living without jQuery</h3>
          <p>
            Backbone Game Engine does not use jQuery. Instead, it depends on <a href="https://github.com/inkling/backbone.native/" target="_blank">backbone.native</a> which re-creates the ubiquitous <code>$</code> function/object with only essentials required by Backbone. As such, you are limited to simple DOM selectors enabled by <a href="https://developer.mozilla.org/en/docs/Web/API/Document.querySelectorAll" target="_blank">querySelectorAll</a> and events. Since the framework is for canvas-based games, avoid HTML manipulations. Canvas-based only allows for easier wrapping with CocoonJS. Consult the documentation of <code>backbone.native</code> to understand limitations.
          </p>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h3 id="documentation-Structure">Directory structure</h3>
          <p>
            To create a new example (or game), create an empty directory at the same level as <code>super-mario-bros</code>. Then, add some files. Here is the recommended file structure:
          </p>
          <pre>
3rd/
src/
...
super-mario-bros/
my-game/
        index.html
        main.js
</pre>
          <p>
            <code>index.html</code> is the HTML document which loads your assets, and defines your canvas. File <code>main.js</code> is where you instantiate the game engine and sprites. It must get loaded last.
          </p>

          <h3 id="documentation-HTML">index.html</h3>
          <p>
            The HTML document (usually named <code>index.html</code> in its own folder) declares the assets to be loaded and the <code>canvas</code> element. Javascript assets are declared in the <code>HEAD</code> element. Images are loaded via <code>IMG</code> elements. They must be hidden with inline CSS. Everything is bootstrap-loaded as declared in the HTML file. There is no asynchronous loading.
          </p>
          <p>
            Here is an example HTML file taken from the example <a href="mario/index.html" target="_blank">Mario</a>.
          </p>
          <pre>
&lt;!doctype html&gt;
&lt;html style="touch-action: none;"&gt;
    &lt;head&gt;
        &lt;title&gt;Mario - Backbone Game Engine&lt;/title&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
        &lt;link href="../favicon.ico" rel="shortcut icon" type="image/x-icon" /&gt;
        &lt;link href="../apple_touch_icon.png" rel="apple-touch-icon" /&gt;

        &lt;meta name="viewport" content="width=960, user-scalable=no"/&gt;
        &lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt;

        &lt;script src="../3rd/underscore.js" type="text/javascript"&gt;&lt;/script&gt;
        &lt;script src="../3rd/backbone.native.js" type="text/javascript"&gt;&lt;/script&gt;
        &lt;script src="../3rd/backbone.js" type="text/javascript"&gt;&lt;/script&gt;

        &lt;script src="../src/shapes.js" type="text/javascript"&gt;&lt;/script&gt;
        &lt;script src="../src/core.js" type="text/javascript"&gt;&lt;/script&gt;
        &lt;script src="../src/input.js" type="text/javascript"&gt;&lt;/script&gt;
        &lt;script src="../src/hero.js" type="text/javascript"&gt;&lt;/script&gt;
        &lt;script src="../src/world.js" type="text/javascript"&gt;&lt;/script&gt;

        &lt;script src="main.js" type="text/javascript"&gt;&lt;/script&gt;

        &lt;style&gt;
            body {
                margin: 0;
                background-color: #000;
            }
            canvas {
                position: fixed;
                top: 0;
                left: 0;
            }
        &lt;/style&gt;

    &lt;/head&gt;

    &lt;body&gt;
        &lt;img id="mario" src="../super-mario-bros/super-mario-2x.png" style="display:none;" /&gt;
        &lt;canvas id="foreground" width="960" height="700"&gt;
            Your browser does not support canvas element.
        &lt;/canvas&gt;
        &lt;canvas id="background" width="960" height="544" style="display:none;"&gt;
            Your browser does not support canvas element.
        &lt;/canvas&gt;
    &lt;/body&gt;

&lt;/html&gt;
</pre>
          <p>
            Some important notes:
          </p>
          <ul>
            <li>HTML meta tags <code>viewport</code> and <code>apple-mobile-web-app-capable</code> ensure the canvas is properly sized on iPads and other mobile devices.  The width of specified there should be the same as the canvas elements.</li>
            <li>Style <code>touch-action: none;</code> on the <code>HTML</code> tag disables touch behaviors, like pan and zoom for IE10.</li>
            <li>Elements must all have ids since we use the native <code>getElementById</code> Javascript function to retrieve the <code>Canvas</code> and <code>Image</code> objects from their respective DOM elements.</li>
            <li>Canvas ided <code>background</code> is used as a secondary buffer in <a href="#documentaiton-World">Backbone.World</a> (to draw the background). It must remain hidden. Its height is less than that of the <code>foreground</code> canvas since the bottom real-estate is taken by either a <a href="#documentation-Input">Backbone.Input</a> or <a href="#documentation-WorldEditor">Backbone.WorldEditor</a> model.</li>
          </ul>

          <h3 id="documentation-main">main.js</h3>
          <p>
            File <code>main.js</code> is where you declare and initialize your objects. It is recommended that you wrap that code in a function which gets executed once the document and all assets are loaded (i.e. window.onload event). You can use for example <code>$(window).on("load", function() {});</code>. 
          </p>
          <p>
            Other files use a simple anonymous function instead since they contain class declarations mainly. However in <code>main.js</code> is where <code>Canvas</code> and <code>Image</code> objects are retrieved from the DOM elements. So they must first be loaded. This keeps things simple. Assets are as a consequence always loaded synchronously.
          </p>
          <p>
            Here is a sample <code>main.js</code> file, taken from the <a href="mario/index.html" target="_blank">Mario</a> example.
          </p>
          <pre>
$(window).on("load", function() {

  // Mario alone in an empty world. Control him with the touchpad.

  Backbone.Mario = Backbone.Hero.extend({
    defaults: _.extend({}, Backbone.Hero.prototype.defaults, {
      name: "mario",
      spriteSheet: "mario"
    })
  });

  var canvas = document.getElementById("foreground");

  var spriteSheets = new Backbone.SpriteSheetCollection([{
    id: "mario",
    img: "#mario",
    tileWidth: 32,
    tileHeight: 64,
    tileColumns: 21,
    tileRows: 6
  }]).attachToSpriteClasses();

  var debugPanel = new Backbone.DebugPanel();

  var input = new Backbone.Input({
    drawTouchpad: true,
    drawPause: true
  });

  var mario = new Backbone.Mario({
    x: 400, y: 400
  }, {
    input: input
  });

  var world = new Backbone.World({
    width: 30, height: 18,
    tileWidth: 32, tileHeight: 32,
    backgroundColor: "rgba(66, 66, 255, 1)"
  });
  world.add(mario);

  var engine = new Backbone.Engine([
    world,
    input,
    debugPanel
  ], {
    canvas: canvas,
    debugPanel: this.debugPanel,
    input: input
  });

  // Expose things as globals - easier to debug
  _.extend(window, {
    canvas: canvas,
    engine: engine
  });

});
</pre>
        </div>
      </div>

      <div id="documentation" class="row">
        <div class="col-md-12">
          <h1>Reference</h1>
          <p>
            Backbone Game Engine defines classes in the <code>Backbone</code> namespace. Most are sub-classed from <code>Backbone.Model</code> or <code>Backbone.Collection</code>.
          </p>
        </div>
      </div>

      <div id="documentation-Engine" class="row">
        <div class="col-md-12">
          <h3>Backbone.Engine</h3>
          <pre>new Backbone.Engine([models], [options])</pre>
          <p>
            The core object to run everything is the <em>engine</em>, a Backbone collection of sprites (Backbone models).
          </p>
          <h4>Options</h4>
          <ul>
            <li><code>canvas</code>: The canvas to draw upon. Drawing is on its 2d context.</li>
            <li><code>input</code>: Optional. The user control input instance. If passed and the pause button is enabled, will stop/start then engine when pressed.</li>
            <li><code>clearOnDraw</code>: Optional. Boolean to ask for a clear of the canvas before redraw. Defaults to false. Note that this is an expensive call. Better to only clear the area that changed.</li>
            <li><code>debugPanel</code>: Optional. A <a href="#documentation-DebugPanel">Backbone.DebugPanel</a> instance. If passed <code>fps</code> and <code>cycleTime</code> are output.</li>
          </ul>
          <p>
            The <code>Backbone.Engine</code> class is a <a href="http://backbonejs.org/#Collection" target="_blank">Backbone.Collection</a> that uses HTML5's <a href="https://developer.mozilla.org/en/docs/Web/API/window.requestAnimationFrame" target="_blank">requestAnimationFrame</a> to provide a 60 frames per second game loop. Every frame, the engine performs these things:
          </p>
          <ul>
            <li>Loop through models (in order), and calls their <code>update</code> method. Passing <code>dt</code>, the time in milliseconds since the last call to update. The update method must return <code>true</code> to ask for a redraw, or <code>false</code> not to.</li>
            <li>Loop through all models that requested a redraw, and call their <code>draw</code> method passing <code>context</code>, the canvas 2d context. Perform whatever magic you like in the draw method.</li>
            <li>Call itself again upon the next animation frame.</li>
          </ul>
          <div class="alert alert-info">Note: By default the engine does not clear the canvas before redraw. You can set the <code>clearOnDraw</code> option to do so however it is an expensive call. Better to do it only when required. See class <a href="#documentation-World">Backbone.World</a> for an example.</div>
          <p>
            The <code>update</code> method is used to update the model position, animation, detect collisions, or whatever you like. If it requests a redraw, the engine will then call its <code>draw</code> method. The engine ensures that models are updated and drawn in the order they are sorted in the collection. You can define the sort order by defining a <a href="http://backbonejs.org/#Collection-comparator" target="_blank">comparator</a>.
          </p>
          <p>
            Models added to the collection receive an <code>attach</code> event and have property <code>engine</code> set as backreference. When removed, they receive a <code>detach</code> event.
          </p>
          <p>
            To measure performance, two properties are set: <code>fps</code> and <code>cycleTime</code>. If you passed option <code>debugPanel</code>, they will be drawn on screen.
          </p>
          <p>
            The engine can be started and stopped. When running, will perform an update/draw sequence 60 times per second. Use methods <code>start</code>, <code>stop</code> or <code>toggle</code>. Use method <code>isRunning</code> to determine if the engine is running. If you passed option <code>input</code>, the engine will bind to the <em>pause</em> button (or the <em>p</em> key) to toggle start/stop.
          </p>
          <h4>Usage</h4>
          <pre>
  var canvas = document.getElementById("foreground");

  var debugPanel = new Backbone.DebugPanel();

  var ball = new Backbone.Ball({
    x: 100, y: 100, color: "blue"
  });

  var engine = new Backbone.Engine([
    ball,
    debugPanel
  ], {
    canvas: canvas,
    debugPanel: debugPanel,
    clearOnDraw: true
  });
</pre>
          <p>
            Taken from the <a href="ball/index.html" target="_blank">Bouncing Ball</a> example. Draws two models: the debug panel and a bouncing ball.
          </p>
        </div>
      </div>

      <div id="documentation-SpriteSheet" class="row">
        <div class="col-md-12">
          <h3>Backbone.SpriteSheet</h3>
          <pre>
new Backbone.SpriteSheet([attributes], [options]);
new Backbone.SpriteSheetCollection([models], [options]);
</pre>
          <p>
            <code>Backbone.SpriteSheet</code> is a Backbone model which breaks an image into frames used for animation. <code>Backbone.SpriteSheetCollection</code> is a Backbone collection of sprite sheets.
          </p>
          <h4>Attributes</h4>
          <ul>
            <li><code>img</code>: The element id selector of the image to find in the DOM. A pointer to the Image object is then stored in property <code>img</code>.</li>
            <li><code>tileWidth, tileHeight</code>: Size of tiles in pixels.</li>
            <li><code>tileColumns, tileRows</code>: Number of tiles in the image.</li>
          </ul>
          <p>
            When the sprite sheet is instantiated, an array of frames is built. A frame object contains the coordinates of the frame. It consists of <code>{x, y, width, height}</code> representing the pixel position and size of the frame. These will be passed to the <a href="https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D#drawImage()" target="_blank">HTML5 canvas drawImage</a> function as arguments <code>sx, sy, sw, sh</code> by the <code>draw</code> method.
          </p>
          <h4>Usage</h4>
          <p>
            Define your sprite sheets by creating a collection as such:
          </p>
          <pre>
this.spriteSheets = new Backbone.SpriteSheetCollection([{
  id: "mario",
  img: "#mario",
  tileWidth: 32,
  tileHeight: 64,
  tileColumns: 21,
  tileRows: 2
}, {
  id: "tiles",
  img: "#tiles",
  tileWidth: 32,
  tileHeight: 32,
  tileColumns: 29,
  tileRows: 28
}]).attachToSpriteClasses();
</pre>
          <p>
            <img src="docs/super-mario-sprite.png" class="img-responsive" alt="Backbone.Input" />
          </p>
          <p>
            Here two sprite sheets are created <code>mario</code> and <code>tiles</code>. Their graphics are in <code>Image</code> objects found in the DOM. The attribute <code>img</code> is the selector to retrieve them. Note that only id selector is supported.
          </p>
          <p>
            Calling method <code>attachToSpriteClasses</code> will attach the sprite sheets to each sprite class found in the <code>Backbone</code> namespace.
          </p>
        </div>
      </div>

      <div id="documentation-Sprite" class="row">
        <div class="col-md-12">
          <h3>Backbone.Sprite</h3>
          <pre>new Backbone.Sprite([attributes], [options]);</pre>
          <p>
            <code>Backbone.Sprite</code> is a <a href="http://backbonejs.org/#Model" target="_blank">Backbone Model</a> which implements the required <code>update</code> and <code>draw</code> methods to animate a sprite, frame by frame.
          </p>
          <h4>Attributes</h4>
          <ul>
            <li><code>x, y</code>: The coordinates in pixels.</li>
            <li><code>width, height</code>: Size of the sprite in pixels.</li>
            <li><code>state</code>: The current animation.</li>
            <li><code>sequenceIndex</code>: The current animation sequence frame. Automatically set.</li>
            <li><code>spriteSheet</code>: Sprite sheet id.</li>
            <li><code>collision</code>: Optional. For use with <a href="#documentation-World">Backbone.World</a>.</li>
            <li><code>static</code>: Optional. For use with <a href="#documentation-World">Backbone.World</a>.</li>
          </ul>
          <p>
            Graphics are obtained from a <a href="#documentation-SpriteSheet">Backbone.SpriteSheet</a> model. In attribute <code>spriteSheet</code>, specify the sprite sheet id you previously defined in a <code>Backbone.SpriteSheetCollection</code> instance. The collection will automatically attach it to the sprite by setting property <code>spriteSheet</code> as back reference. Building on the example above:
          </p>
          <pre>
var spriteSheets = new Backbone.SpriteSheetCollection([{
  id: "mario",
  img: "#mario",
  tileWidth: 32,
  tileHeight: 64,
  tileColumns: 21,
  tileRows: 2
}]).attachToSpriteClasses();

var mario = new Backbone.Mario({
  spriteSheet: "mario"
});

mario.get("spriteSheet");
// mario

spriteSheets.get("mario");
// child {cid: "c2", attributes: Object, collection: child, _changing: false, _previousAttributes: Object…}

mario.spriteSheet;
// child {cid: "c2", attributes: Object, collection: child, _changing: false, _previousAttributes: Object…}
</pre>
          <h4>Inheritance</h4>
          <p>
            Instantiating a <code>Backbone.Sprite</code> model is not very useful by itself. You must first extend the <code>Backbone.Sprite</code> class to provide your own animations and a pointer to the sprite sheet. For example this defines a sprite with 3 animations <code>idle</code>, <code>walk-left</code> and <code>walk-right</code>. It points to the sprite sheet id <code>mario</code>.
          </p>
          <pre>
Backbone.MySprite = Backbone.Sprite.extend({
  defaults: {
    x: 400,
    y: 400,
    spriteSheet: "mario",
    state: "idle",
    sequenceIndex: 0,
    static: false,
    collision: true
  },
  animations: {
    idle: {
      sequences: [0]
    },
    "walk-right": {
      sequences: [1, 2, 3, 2],
      delay: 200
    },
    "walk-left": {
      sequences: [1, 2, 3, 2],
      scaleX: -1,
      delay: 200
    }
  }
});
</pre>

          <p>
            Above, the <code>Backbone.Sprite</code> was sub-classed using <code>extend</code> method. <code>defaults</code> are the default attributes to give any new <code>Backbone.MySprite</code> instance. Same thing for <code>animations</code>.
          </p>
          <p>
            If you want to reuse parts of <code>defaults</code> or <code>animations</code> from a parent class, make sure to make a copy. You can use the helper function <code>_.deepClone</code> for that purpose (<code>_.clone</code> only goes one level deep). Otherwise you may change the parent class behavior. For example the <code>Backbone.PennieUg</code> class reuses the <code>Backbone.Pennie</code> class' properties <code>defaults</code> and <code>animations</code> by first creating copies.
          </p>
          <pre>

  Backbone.PennieUg = Backbone.Pennie.extend({
    defaults: _.extend(_.deepClone(Backbone.Pennie.prototype.defaults), {
      name: "pennie-ug"
    }),
    animations: _.deepClone(Backbone.Pennie.prototype.animations)
  });
  Backbone.PennieUg.prototype.animations.idle.sequences = [168, 168, 169, 170, 169, 168];
</pre>
          <div class="alert alert-info">
            Helper function <code>deepClone</code> was created a mixin of <code>underscore</code>. When it make sense, make general functions available that way. Look at the end of <code>src/core.js</code> for all mixins.
          </div>
          <h4>Animations</h4>
          <p>
            Sprite property <code>animations</code> contains a hash of animations. Each animation contains a sequence of frames and a delay between frames for animation. For example:
          </p>
          <pre>
animations: {
  idle: {
    sequences: [0, 1],
    delay: 200
  }
}
</pre>
          <p>
            This defines an animation of two frames, alternating at an interval of 200ms. Values 0 and 1 in array <code>sequences</code> are frame indices defined in the sprite sheet. Sprite attributes <code>state</code> and <code>sequenceIndex</code> control which animation and sequence are currently used. The <code>sequenceIndex</code> is automatically incremented (and reset to 0) by the sprite's draw function. Attribute <code>state</code> determines the current animation. It must be set to <code>idle</code> in the above example (as there is only one).
          </p>
          <p>
            Extra animation options are available. Here is a complete list:
          </p>
          <ul>
            <li><code>sequences</code>: Array of frame indices, or squence objects. A sequence object looks like this: <code>{frame: 52, x: 0, y: -32, scaleX: 1.00, scaleY: 1}</code>. It allows you to specify an offset to apply when the sprite is drawn, and a scaling factor.</li>
            <li><code>scaleX, scaleY</code>: Optional. Scaling factors. Set <code>scaleX</code> to -1 to flip horizontally. Defaults to 1 if omitted.</li>
            <li><code>delay</code>: Optional. The time to change to the next sequence. No need to specify if there is only one frame (as there is no animation). You can also define a sprite method <code>sequenceDelay</code> to programmatically return the delay. It will be passed the current animation.</li>
          </ul>
          <p>
            For detailed examples of animations, look at file <code>artifacts.js</code> in the <code>super-mario-bros</code> folder. Class <code>Backbone.Pennie</code> implements a basic animation sequence using frame indices, while <code>Backbone.FlyingPennie</code> implements a more complex animation with sequence objects.
          </p>
          <pre>
Backbone.Pennie = Backbone.AnimatedTile.extend({
  ...
  animations: {
    idle: {
      sequences: [52, 52, 53, 54, 53, 52],
      delay: 50
    }
  },
  ...

Backbone.FlyingPennie = Backbone.Sprite.extend({
  ...
  animations: {
    anim: {
      sequences: [
        {frame: 52, x: 0, y: -32, scaleX: 1.00, scaleY: 1},
        {frame: 52, x: 0, y: -64, scaleX: 0.50, scaleY: 1},
        {frame: 53, x: 0, y: -90, scaleX: 0.50, scaleY: 1},
        {frame: 53, x: 0, y: -128, scaleX: 1.00, scaleY: 1},
        {frame: 53, x: 0, y: -128, scaleX: 0.50, scaleY: 1},
        {frame: 52, x: 0, y: -112, scaleX: 0.50, scaleY: 1},
        {frame: 52, x: 0, y: -90, scaleX: 1.00, scaleY: 1},
        {frame: 52, x: 0, y: -80, scaleX: 0.50, scaleY: 1},
        {frame: 53, x: 0, y: -80, scaleX: 0.50, scaleY: 1}
      ],
      delay: 50
    }
  },
  ...

</pre>
        </div>
      </div>

      <div id="documentation-Input" class="row">
        <div class="col-md-12">
          <h3>Backbone.Input</h3>
          <pre>new Backbone.Input([attributes], [options]);</pre>
          <p>
            <code>Backbone.Input</code> class is a model which captures user input events and stores them as model attributes. For example pressing the left arrow, sets the <code>left</code> attribute to <code>true</code>. Depressing sets it to <code>false</code>. Bind to on the attribute change event to be notified.
          </p>
          <p>
            <code>Backbone.Input</code> supports keyboard, mouse and touch events. It can draw a touchpad on screen with left and right arrow keys, an A button and a B button. Optionally, a pause button can be drawn in the middle, or the area can be used to place a banner ad.
          </p>
          <p>
            <img src="docs/input.png" class="img-responsive" alt="Backbone.Input" />
          </p>
          <div class="alert alert-info">
            Note: The Backbone.Input model only captures input when attached to a Backbone.Engine.
          </div>
          <h4>Attributes</h4>
          <p>These attributes can be passed when creating the model, to configure the input.</p>
          <ul>
            <li><code>drawTouchpad</code>: Optional. Boolean to indicate whether to draw the touchpad. Defaults to true.</li>
            <li><code>drawPause</code>: Optional. Boolean to indicate whether to draw the pause button on the touchpad. Defaults to false.</li>
          </ul>
          <p>The following model attributes are set by the model. They should not be set externally.</p>
          <ul>
            <li><code>touchEnabled</code>: Boolean set to true if the device is touch enabled.</li>
            <li><code>left</code>: Boolean set to true when the left touchpad arrow or left keyboard arrow key is pressed.</li>
            <li><code>right</code>: Boolean set to true when the right touchpad arrow or right keyboard arrow key is pressed.</li>
            <li><code>buttonA</code>: Boolean set to true when the A touchpad button is pressed, or when the z keyboard key is pressed.</li>
            <li><code>buttonB</code>: Boolean set to true when the B touchpad button is pressed, or when the x keyboard key is pressed.</li>
            <li><code>pause</code>: Boolean set to true when the pause touchpad button is pressed, or when the p keyboard key is pressed.</li>
            <li><code>pressed</code>: Array of keys pressed on the keyboard.</li>
            <li><code>touched</code>: Array of buttons touched on touch screen.</li>
            <li><code>clicked</code>: Boolean set to true when a mouse button is pressed.</li>
          </ul>
          <h4>Helper methods</h4>
          <p>
            The following helper methods can be called ro find out what buttons are pressed.
          </p>
          <ul>
            <li><code>leftPressed</code></li>
            <li><code>rightPressed</code></li>
            <li><code>buttonAPressed</code></li>
            <li><code>buttonBPressed</code></li>
            <li><code>pausePressed</code></li>
          </ul>
          <h4>Usage</h4>
          <pre>
var input = new Backbone.Input();
var engine = new Backbone.Engine([input]);
input.bind("change:left", function(input) {
  if (input.leftPressed())
    console.log("left pressed:)");
  else
    console.log("left depressed:(");
});
</pre>
        </div>
      </div>

      <div id="documentation-World" class="row">
        <div class="col-md-12">
          <h3>Backbone.World</h3>
          <pre>new Backbone.World([attributes], [options])</pre>
          <p>
            <code>Backbone.World</code> is model which contains a collection of sprites.
          </p>
          <h4>Attributes</h4>
          <ul>
            <li><code>x, y</code>: Origin of top-left corner in pixels.</li>
            <li><code>width, height</code>: Size of world in tiles.</li>
            <li><code>tileWidth, tileHeight</code>: Size of a tile in pixels.</li>
            <li><code>hero</code>: Name of sprite character controlled by the user. Will be passed the input as option when instantiated.</li>
            <li><code>sprites</code>: Array of sprite models for persistence.</li>
            <li><code>backgroundColor</code>: Background color of the world.</li>
            <li><code>state</code>: Persisted state either play or edit.</li>
          </ul>
          <h4>Options</h4>
          <ul>
            <li><code>backgroundImage</code>: Optional. Pass to use a background image instead of a background color. Anchored to the origin.</li>
            <li><code>input</code>: Input instance to control the hero.</li>
            <li><code>camera</code>: Camera instance to keep the hero in the viewport.</li>
            <li><code>debugPanel</code>: Optional.</li>
          </ul>
          <p>
            Sprites can be added and removed via methods <code>add</code> and <code>remove</code>. Sprites are automatically attached to the <a href="#documentation-Engine" target="_blank">Backbone.Engine</a> the world is attached to. In each request frame, the same mechanics apply as for sprites attached directly to an engine; methods <code>update</code> and <code>draw</code> are called for each sprite. The exception is for static sprites which are only updated/redrawn when required (see below).
          </p>
          <p>
            A world is measured in tiles via attributes <code>width</code>, <code>height</code>, <code>tileWidth</code> and <code>tileHeight</code>. Call methods <code>width</code> and <code>height</code> to get the size in pixels. Attributes <code>x</code> and <code>y</code> determine the origin in pixels (top-left corner) and allow the world to be panned consequently changing the viewport.
          </p>
          <p>
            Methods <code>getWorldIndex</code>, <code>getWorldCol</code> and <code>getWorldRow</code> can be used to find the position of a sprite. A sprite's <code>x</code> and <code>y</code> attributes determine their position relative to the world origin.
          </p>
          <p>
            Internally, the world keeps sprites into a collection stored in property <code>sprites</code>. It further splits sprites into 2 collections for faster lookup:
          </p>
          <ul>
            <li><code>staticSprites</code>: Background sprites that have no animation. These are usually same-sized tiles. Sprites that have their <code>static</code> attribute set to true will be put in this collection. Sprites are given an <code>id</code> determined by their position (column and row). The collection is ordered and indexed on <code>id</code> allowing for fast lookup on a pair of x/y coordinates. In addition, these sprites are only drawn when required (i.e. world is panned). Use method <code>findCollidingAt</code> for quick lookup.</li>
            <li><code>dynamicSprites</code>: Animated tiles and characters. Their <code>static</code> attribute must be set to false to fall in this collection. These sprites are given unique <code>id</code> attributes based on their name (i.e. <code>mario.1</code>). They are not indexed therefore lookup has an order of N. Keep the number of sprites here to a minimum. Use methods <code>findAt</code> and <code>filterAt</code> to find collisions with other sprites.</li>
          </ul>
          <div class="alert alert-info">
            Note: If you define a non-animated tile, make sure its <code>static</code> attribute is set to true. Also ensure the width of tile sprites match that of world attributes <code>tileWidth</code> and <code>tileHeight</code>. Lookup methods perform calculations assuming these things hold true.
          </div>
          <h4>Sprites</h4>
          <p>
            When the world is created, sprites are instantiated in method <code>spawnSprites</code>. Each sprite instance is attached to the engine. Sprites then have properties <code>engine</code> and <code>world</code> set pointing to those respective objects.
          </p>
          <p>
            Sprites can be categorized with attribute <code>type</code> as to identify one another when they interact with each other. Sprites of type <code>tile</code> Are usually static and obstacles. Sprites of type <code>character</code> are usually dynamic and moving sprites.
          </p>
          <p>
            You can add sprites with method <code>add</code> which delegates to the <code>sprites</code> collection's <code>add</code> method. It takes care of passing the <code>world</code> as option.
          </p>
          <p>
            You can also use method <code>cloneAtPosition(sprite, x, y)</code>. It takes as argument an existing sprite, and coordinates. It will clone the sprite and place it at the specified coordinates passing <code>world</code> as option. If the sprite name matches that of the world attribute <code>hero</code> it will also pass option <code>input</code>, and if a <code>Backbone.Camera</code> exists, it will be tied to it. Backbone.WorldEditor</code> uses this function for instance.
          </p>
          <h4>Background and Tiles</h4>
          <p>
            The background of a world is composed of same-size tiles defined by attributes <code>tileWidth</code> and <code>tileHeight</code>. A tile is a sprite with <code>static</code> attribute set to true. The model <code>id</code> is the position of the sprite on screen (column and row). As such, there can only be one tile per location.
          </p>
          <p>
            You can find if a tile is at a specific coordinate with method <code>findCollidingAt(x, y)</code>. This method is fast because lookup is based on id; an index of the position. It should be used to detect sprite collisions with tiles.
          </p>
          <h4>Character Sprites</h4>
          <p>
            Characters are sprites that interact with their environment. <code>Backbone.Hero</code> is a character, and so are enemies in the Super Mario Bros example. Character sprite models must have a <code>type</code> attribute set to <code>character</code>. Method <code>findAt(x, y, [type], [exclude], [collision])</code> will return the top-most sprite at a specific coordinate. Method <code>filterAt(x, y, [type], [exclude], [collision])</code> will return all sprites at a specific coordinate. Optional arguments allow filtering:
          </p>
          <ul>
            <li><code>type</code>: Optional. If set, will only lookup sprites matching that type.</li>
            <li><code>exlcude</code>: Optional. The sprite model to exclude in lookup.</li>
            <li><code>collision</code>: Optional. Boolean indicating whether to only include sprites that have the <code>collision</code> attribute explicitly set to <code>true</code>.
          </ul>
          <p>
            Those methods can be used to detect collisions between characters.
          </p>
          <h4>Persistence</h4>
          <p>
            The world model attributes contain all that is necessary to persist the state of the world to disk, or in the cloud. Calling the <code>save</code> method first serializes the sprite collection into the <code>sprites</code> attribute by calling the <code>toSave</code> method on each sprite to save their position and state. It then delegates to the backbone model's <code>save</code> method to save to a server or local storage in JSON format. See the Backbone documentation for details.
          </p>
          <p>
            The world can be restored by calling <code>restore</code> and passing as argument a saved world in JSON format.
          </p>
          <h4>Usage</h4>
          <pre>
  var mario = new Backbone.Mario({
    x: 400, y: 400
  });

  var world = new Backbone.World({
    width: 30, height: 18,
    tileWidth: 32, tileHeight: 32,
    backgroundColor: "rgba(66, 66, 255, 1)"
  });
  world.add(mario);

  var engine = new Backbone.Engine([
    world
  ]);
</pre>
        <p>
          A sprite (mario) is first created and added it the world. The world is then added to the engine. This is taken from file <code>mario/main.js</code> for the Mario example.
        </p>
        </div>
      </div>

      <div id="documentation-WorldEditor" class="row">
        <div class="col-md-12">
          <h3>Backbone.WorldEditor</h3>
          <pre>new Backbone.WorldEditor([attributes], [options])</pre>
          <p>
            <code>Backbone.WorldEditor</code> is a model which displays a palette of sprites and allows the user to edit a <code>Backbone.World</code> instance by placing and removing sprites. Also allows the user to pan the world. An editor is usually drawn at the bottom of the world replacing the <a href="#documentation-Input">Backbone.Input</a>. It must be attached to a <code>Backbone.Engine</code> model.
          </p>
          <p>
            <img src="docs/world-editor.png" class="img-responsive" alt="Backbone.Input" />
          </p>
          <h4>Attributes</h4>
          <ul>
            <li><code>x, y</code>: Placement position in pixels of the editor on the canvas.</li>
            <li><code>width, height</code>: Size of editor in pixels.</li>
            <li><code>tileWidth, tileHeight</code>: Size of sprites in the palette.</li>
            <li><code>padding</code>: Padding in pixels around sprites.</li>
            <li><code>backgroundColor</code>: Background color of the editor.</li>
            <li><code>selectColor</code>: Background and outline color of a selected sprite.</li>
            <li><code>selected</code>: The name of the cuurrently selected sprite.</li>
            <li><code>spriteNames</code>: Ordered array of sprite names in the palette.</li>
          </ul>
          <h4>Options</h4>
          <ul>
            <li><code>world</code>: The Backbone.World to edit.</li>
          </ul>
          <p>
            The palette is drawn as a series of tiles left to right, top to bottom. Each tile is a sprite. The sprite may be bigger than the specified tile size, in which case it will overlap over tiles to the right or to the bottom. Therefore keep offsize sprites last, and keep an empty row below.
          </p>
          <div class="alert alert-info">
            Note: Backbone.WorldEditor depends on <a href="http://eightmedia.github.io/hammer.js/" target="_blank">hammer.js</a> for touch events (and mouse events). It allows panning of the world, and selection of sprites.
          </div>
        </div>
      </div>

      <div id="documentation-Hero" class="row">
        <div class="col-md-12">
          <h3>Backbone.Hero</h3>
          <pre>new Backbone.Hero([attributes], [options])</pre>
          <p>
            The <code>Backbone.Hero</code> is a sub-classed <code>Backbone.Sprite</code> which implements a controlable character with input and physics. Its playability is based on that of Mario in the Nintendo classic Super Mario Bros.
          </p>
          <div class="alert alert-info">
            A <code>Backbone.Hero</code> must live inside a <code>Backbone.World</code>.
          </div>
          <h4>Attributes</h4>
          <ul>
            <li><code>x, y</code>: Position of the sprite.</li>
            <li><code>width, height</code>: Size of the sprite in pixels. Defaults to  32 x 64.</li>
            <li><code>name</code>: Name of the sprite. Defaults to mario.</li>
            <li><code>type</code>: Type of sprite. Defaults to character.</li>
            <li><code>spriteSheet</code>: Id of sprite sheet.</li>
            <li><code>state</code>: Current animation. Starts with idle-right.</li>
            <li><code>collision</code>: Boolean indicating whether it can be detected by other sprites. Defaults to true.</li>
            <li><code>powerUp</code>: Whether Mario is small or big. Defaults to small.</li>
            <li><code>velocity, acceleration</code>: Current horizontal movement. Do not set.</li>
            <li><code>yVelocity, yAcceleration</code>: Current vertical movement. Do not set.</li>
          </ul>
          <h4>Options</h4>
          <ul>
            <li><code>input</code>: Optional. A <code>Backbone.Input</code> instance to allow control of the character with the keyboard (left and right arrows, z and x) or via touch events on the on-screen drawn gamepad.</li>
          </ul>
          <p>
            Attribute <code>state</code> determines the current animation. A state is a pair of move and direction. For example <code>idle-right</code>, <code>walk-left</code> and <code>jump-right</code>. Method <code>getStateInfo</code> will decompose the state for you into those components.
          </p>
          <p>
            With attribute <code>nextState</code>, we are able to implement tweens, or in-between animations. For example, holding the right arrow button puts the hero in a <code>walk-right</code> state (and <code>slide-right</code> next state). Releasing the right arrow button transitions to the <code>slide-right</code> state (and <code>idle-right</code> next state) for quick decelration until velocity reaches 0 to fall to the <code>idle-right</code> state. If instead the left arrow button is pressed, we transition to the <code>skid-left</code> state (and <code>walk-left</code> next state) for quicker decelartion until velocity reaches 0 to then accelerate in the opposite direction to fall in the <code>walk-left</code> state (and <code>slide-left</code> next state).
          </p>
          <p>
            Holding an arrow button and the A button (z on keyboard) allows the character to run. Its state becomes <code>run-right</code> (or <code>run-left</code>). Pressing the B button allows the character to jump (<code>jump-left</code> or <code>jump-right</code>). Hold the B button to jump higher. You can control the direction and distance jumped with the arrow buttons. And like in the real game, a jump while running will go higher to cover more distance.
          </p>
          <p>
            Physics are implemented with attributes <code>velocity</code>, <code>acceleration</code>, <code>yVelocity</code> and <code>yAcceleration</code> measured in pixels per seconds. The two first control horizontal translations over time where a positive <code>velocity</code> indicates a move to the right, and negative to the left. The latter two control vertical translations where a positive <code>yVelocity</code> indicates a move downwards, and negative upwards.
          </p>
          <p>
            Each animation have targets of these properties when required. They are omitted otherwise (i.e. <code>walk-right</code> has no <code>yVelocity</code> or <code>yAcceleration</code>). The <code>update</code> method updates the model attributes according to the targets configured on the current animation. When <code>state</code> changes to another animation, so do the targets, and so follow the actual velocities over time to reach their targets. This gives the character momentum.
          </p>
          <p>
            Gravity is implemented with a positive <code>yAcceleration</code>. Unless atop a tile, our character will fall. However it is constrained by the extent of the <code>Backbone.World</code> it is contained in. And will therefore stop falling when the bottom is reached.
          </p>
          <h4>Collisions</h4>
          <p>
            Our character detects collisions either from tiles or other characters to constrain its movements. It does so using collision detection methods from <code>Backbone.World</code>: <code>findCollidingAt</code> for tiles, and <code>findAt</code> for other characters. Every <code>update</code>, a check for collisions is made at 8 possible locations on the outline of the sprite:
          </p>
          <p>
            <img class="img-responsive" src="docs/hero-collisions.png" alt="Hero Collisions" />
          </p>
          <p>
            Collisions are only detected when necessary. For instance, when jumping collisions are detected top and right only. The decision is based on looking at <code>velocity</code> and <code>yVelocity</code>.
          </p>
          <pre>
if (velocity &gt;= 0) {
  // Stop if obstacle to the right
  var rightTopTile = obstacleCheckTopY > 0 ? this.world.findCollidingAt(heroLeftX + heroWidth, obstacleCheckTopY) : null,
      rightBottomTile = obstacleCheckBottomY > 0 ? this.world.findCollidingAt(heroLeftX + heroWidth, obstacleCheckBottomY) : null,
      rightBottomEnemie = this.world.findAt(heroLeftX + heroWidth, obstacleCheckBottomY, "character", this, true),
      rightX = _.minNotNull([
        this.world.width(),
        rightTopTile ? rightTopTile.get("x") : null,
        rightBottomTile ? rightBottomTile.get("x") : null,
        rightBottomEnemie ? rightBottomEnemie.get("x") : null
      ]);
</pre>
          <p>
            When an obstacle is hit, the character stops moving. Its <code>x</code> is anchored, and <code>velocity</code> set to 0.
          </p>
          <pre>
if (heroLeftX + heroWidth >= rightX) {
  if (!rightTopTile &amp;&amp; !rightBottomTile &amp;&amp; !rightBottomEnemie ||
      rightTopTile ||
      rightBottomTile ||
      rightBottomEnemie &amp;&amp; rightBottomEnemie.isBlocking(this, "left")) {
    attrs.velocity = velocity = 0;
    attrs.x = x = rightX - heroWidth;
  }
  if (rightBottomEnemie) rightBottomEnemie.trigger("hit", this, "left");
}
</pre>
          <p>
            A collision with another character triggers an <code>hit</code> event on that sprite. The event hanlder will receive the colliding sprite (hero), and its relative position where the hit occured (left of the enemie sprite in this case).
          </p>
          <h4>Usage</h4>
          <p>
            This excerpt is taken from the Mario example.
          </p>
          <pre>
  Backbone.Mario = Backbone.Hero.extend({
    defaults: _.extend({}, Backbone.Hero.prototype.defaults, {
      name: "mario",
      spriteSheet: "mario"
    })
  });

  var canvas = document.getElementById("foreground");

  var spriteSheets = new Backbone.SpriteSheetCollection([{
    id: "mario",
    img: "#mario",
    tileWidth: 32,
    tileHeight: 64,
    tileColumns: 21,
    tileRows: 6
  }]).attachToSpriteClasses();

  var input = new Backbone.Input({
    drawTouchpad: true,
    drawPause: true
  });

  var mario = new Backbone.Mario({
    x: 400, y: 400
  }, {
    input: input
  });

  var world = new Backbone.World({
    width: 30, height: 18,
    tileWidth: 32, tileHeight: 32,
    backgroundColor: "rgba(66, 66, 255, 1)"
  });
  world.add(mario);

  var engine = new Backbone.Engine([
    world,
    input
  ], {
    canvas: canvas,
    input: input
  });
</pre>
        </div>
      </div>

      <div id="documentation-Camera" class="row">
        <div class="col-md-12">
          <h3>Backbone.Camera</h3>
          <pre>new Backbone.Camera([attributes], [options])</pre>
          <p>
            Backbone.Camera is a model which ensures a sprite, the subject, is always in the viewport (the canvas). It pans the Backbone.World when the character steps out of a window in the viewport. Backbone.Camera must be added to the engine.
          </p>
          <h4>Attributes</h4>
          <ul>
            <li><code>left, right, top, bottom</code>: Coordinates of the window with respect to the drawn canvas.</li>
          </ul>
          <h4>Options</h4>
          <ul>
            <li><code>subject</code>: The sprite to keep in the viewport.</li>
            <li><code>world</code>: The Backbone.World.</li>
          </ul>
          <h4>Usage</h4>
          <pre>
var spriteSheets = new Backbone.SpriteSheetCollection({
  id: "mario",
  img: "#mario",
  tileWidth: 32,
  tileHeight: 64,
  tileColumns: 21,
  tileRows: 6
});
var mario = new Backbone.Mario();
var world = new Backbone.World();
var camera = new Backbone.Camera(
  {left: 200, right: 600, top: 0, bottom: 800},
  {subject: mario, world: world}
);
world.add(mario);
var engine = new Backbone.Engine([world, camera]);
</pre>
        </div>
      </div>

      <div id="documentation-Clock" class="row">
        <div class="col-md-12">
          <h3>Backbone.Clock</h3>
          <p>
            <code>Backbone.Clock</code> is a model which ticks at a set time interval. Attribute <code>ticks</code> stores an integer tick value that gets incremented every interval. Useful for synchronizing sprite animations.
          </p>
          <h4>Attributes</h4>
          <ul>
            <li><code>ticks</code>: Initial tick value. An integer that gets incremented every interval.</li>
            <li><code>delay</code>: Interval between ticks.</li>
          </ul>
          <h4>Usage</h4>
          <pre>
var clock = new Backbone.Clock({delay: 2000});
clock.on("change:ticks", function() {
  console.log("tick", clock.get("ticks");
});
</pre>
          <p>
            As an example, look at the Super Mario Bros example, question blocks and pennies are all synced on the same clock. These sprites are sub-classes of <code>Backbone.AnimatedTile</code>. Instances create a Backbone.Clock if one does not exist. Otherwise, they find the existing one by that name and reuse it.
          </p>
          <pre>
Backbone.AnimatedTile = Backbone.Tile.extend({
  initialize: function(attributes, options) {
    Backbone.Tile.prototype.initialize.apply(this, arguments);
    this.on("attach", this.onAttach, this);
    this.on("detach", this.onDetach, this);
  },
  onAttach: function() {
    if (!this.engine) return;
    this.onDetach();

    this.clock = this.engine.findWhere({name: "animatedTileClock"});

    if (!this.clock)
      this.clock = this.engine.add(new Backbone.Clock({name: "animatedTileClock", delay: 200}));

    this.listenTo(this.clock, "change:ticks", this.updateAnimationIndex);
  },
  onDetach: function() {
    if (this.clock) this.stopListening(this.clock);
    this.clock = undefined;
  },
  update: function(dt) {
    return true;
  },
  updateAnimationIndex: function() {
    var animation = this.getAnimation(),
        sequenceIndex = this.get("sequenceIndex") || 0;
    if (!animation) return;
    this.set("sequenceIndex", sequenceIndex < animation.sequences.length-1 ? sequenceIndex + 1 : 0);
  }
});
</pre>
        </div>
      </div>

      <div id="documentation-Button" class="row">
        <div class="col-md-12">
          <h3>Backbone.Button</h3>
          <p>
            <code>Backbone.Button</code> is a model that draws a button with an image. It uses <a href="http://eightmedia.github.io/hammer.js/" target="_blank">hammer.js</a> to detect touch or mouse click events, and triggers a <code>tap</code> event when pressed.
          </p>
          <h4>Attributes</h4>
          <ul>
            <li><code>x, y</code>: Top left corner of button.</li>
            <li><code>width, height</code>: Size of button.</li>
            <li><code>borderRadius</code>: Border radius in pixels for rounded corners.</li>
            <li><code>img</code>: Id selector of DOM element containing the source image (i.e. #buttons). When the button is initialized, will be used to find the Image object, and set property img to point to it.</li>
            <li><code>imgX, imgY, imgWidth, imgHeight</code>: Bounding box of image location in source image.</li>
            <li><code>imgMargin</code>: Offset in pixels to apply when drawing the image inside the button.</li>
            <li><code>backgroundColor</code>: Fill style of the button.</li>
          </ul>
          <h4>Usage</h4>
          <pre>
var button = new Backbone.Button({
  x: 4, y: 4, width: 52, height: 52, borderRadius: 5,
  img: "#icons", imgX: 0, imgY: 0, imgWidth: 32, imgHeight: 32, imgMargin: 10
});
button.on("tap", function() {
  console.log("button tapped!");
});
</pre>
        </div>
      </div>

      <div id="documentation-DebugPanel" class="row">
        <div class="col-md-12">
          <h3>Backbone.DebugPanel</h3>
          <p>
            <code>Backbone.DebugPanel</code> is a Backbone model on which you set attributes to be dumped on screen. Upon draw, it will <code>JSON.stringify</code> attributes.
          </p>
          <h4>Usage</h4>
          <pre>
var debugPanel = new Backbone.DebugPanel();
var engine = new Backbone.Engine([
  debugPanel: debugPanel
], {
  debugPanel: debugPanel
});

debugPanel.set({hello: "Word"});
// Draws this on screen
// {"fps": 58, "ct": 7, "hello": "World"}

debugPanel.set({hello: "Dolly"});
// {"fps": 58, "ct": 7, "hello": "Dolly"}

debugPanel.unset("hello");
// {"fps": 58, "ct": 7}
</pre>
          <p>
            In the above example, the debug panel is created. It is added to the engine as a model to draw. It is also passed as an option to the engine so it can output <code>fps</code> and <code>ct</code> (cycle time).
          </p>
          <p>
            We manually add attribute <code>hello</code> to be tracked. Whenever it changes, so does the print out on screen. Use <code>unset</code> to remove a tracked attribute.
          </p>
          <h4>Conditional Usage</h4>
          <p>
            It is recommended that you support the non-existence of the debug panel with an <code>if (this.debugPanel)</code> statement before setting. For example, when you extend a class, pass in the debug panel as an option. Then, in your code, check to see if it exists. For example, this is done in the <code>Backbone.Engine.draw</code> method:
          </p>
          <pre>if (this.debugPanel) this.debugPanel.set({fps: this.fps, ct: this.cycleTime});</pre>
          <p>
            This supports the case where the debug panel is never created (<code>debugPanel</code> = <code>undefined</code>), such as in production.
          </p>
        </div>
      </div>

      <div id="documentation-Shapes" class="row">
        <div class="col-md-12">
          <h3>Shape functions</h3>
          <p>
            File <code>shapes.js</code> contains helper functions to draw elementary shapes in the 2d drawing context of a canvas. You are free to use direct methods on the context to draw. These are provided as convenience. The functions are added to the global scope, under <code>window</code>. Supported functions are:
          </p>
          <pre>
drawRect(ctx, x, y, width, height, fill, stroke)
drawCircle(ctx, x, y, radius, fill, stroke)
drawRoundRect(ctx, x, y, width, height, radius, fill, stroke)
</pre>
          <p>
            I encourage you to add your own. If you do, respect these recommendations:
          </p>
          <ul>
            <li>Functions take as first argument <code>ctx</code> the drawing context.</li>
            <li>Second and third arguments should be <code>x</code> and <code>y</code> coordinates.</li>
            <li>Last arguments should be <code>fill</code> the fill style, and <code>stroke</code> the stroke style. They should be optional if possible.</li>
          </ul>
        </div>
      </div>

      <div id="going-offline" class="row">
        <div class="col-md-12">
          <h1>Going Offline</h1>
          <p>
            With <a href="https://developer.apple.com/library/safari/documentation/iphone/conceptual/safarijsdatabaseguide/offlineapplicationcache/offlineapplicationcache.html" target="_blank">HTML Application Cache</a>, you can go offline with your game. <a href="super-mario-bros/index.html" target="_blank">Super Mario Bros level 1-1</a> uses the application cache. The first time your browser loads that page, it will save the web page, along with all assets in its application cache. Subsequent visits will load these from the application cache instead of the server.
          </p>
          <div class="alert alert-info">
            Note: Application Cache only works when loaded from a server. It will not if you have forked the repo, and are loading the file from your disk (<code>file:///</code>). That's good because under development, we want to load the new code every refresh.
          </div>
          <p>
            If you have Google Chrome, open the console and you will see this:
          </p>
          <pre>
Creating Application Cache with manifest http://martindrapeau.github.io/backbone-game-engine/super-mario-bros/offline.appcache
Application Cache Checking event martindrapeau.github.io/:1
Application Cache Downloading event martindrapeau.github.io/:1
Application Cache Progress event (0 of 23) http://martindrapeau.github.io/backbone-game-engine/3rd/hammer.js
Application Cache Progress event (1 of 23) http://martindrapeau.github.io/backbone-game-engine/src/input.js
...
Application Cache Progress event (22 of 23) http://martindrapeau.github.io/backbone-game-engine/super-mario-bros/super-mario-enemies-2x.png
Application Cache Progress event (23 of 23)
Application Cache Cached event 
</pre>
          <p>
            Subsequent times, you will see this:
          </p>
          <pre>
Document was loaded from Application Cache with manifest http://martindrapeau.github.io/backbone-game-engine/super-mario-bros/offline.appcache
Application Cache Checking event
Application Cache NoUpdate event
</pre>
        <h3>Manifest File</h3>
        <p>
          Using an Application Cache is dead simple. First you must add the <code>manifest</code> attribute to your HTML tag. It points to the manifest file:
        </p>
        <pre>
&lt;!doctype html&gt;
&lt;html manifest="offline.appcache"&gt;
    &lt;head&gt;
</pre>
          Second, create the <code>manifest</code> file. It contains files that must be cached. For example here is the <code>offline.manifest</code>:
        </p>
        <pre>
CACHE MANIFEST
# Version 0.11 (c) 2014 Martin Drapeau

../3rd/hammer.js
../3rd/underscore.js
../3rd/backbone.native.js
../3rd/backbone.js

../src/input.js
../src/shapes.js
../src/core.js
../src/world.js
../src/local-storage.js
../src/camera.js
../src/editor.js
../src/hero.js

mario.js
tiles.js
artifacts.js
enemies.js
display.js
level_1-1.js
main.js

super-mario-2x.png
super-mario-tiles-2x.png
super-mario-enemies-2x.png
icons.png
</pre>
          <p>
            If you have server requests, you can add a <code>NETWORK</code> section. Consult the docs for details.
          </p>
          <p>
            Fianally, the comment with <code>Version 0.11</code> is important. When I release a new version of Super Mario Bros level 1-1, I increase that number to force the browser to reload the files. It will also trigger an <code>updateready</code> event which I capture. I then show a download button to inform the user a new version is ready to be downloaded. Clicking on that button simply refreshes the browser to reload the new version.
          </p>
        </div>
      </div>

      <div id="persistence" class="row">
        <div class="col-md-12">
          <h1>Persistence</h1>
          <p>
            Backbone offers RESTful persistence via <a href="http://backbonejs.org/#Sync" target="_blank">Backbone.sync</a>. Models have methods <code>fetch</code> and <code>save</code> to send/retrieve the model/collection JSONified data to/from the server. As such, you can easily implement server-side persistence using well established RESTful standards.
          </p>
          <p>
            In our Super Mario Bros example, we use <a href="https://developer.apple.com/library/safari/documentation/iPhone/Conceptual/SafariJSDatabaseGuide/Name-ValueStorage/Name-ValueStorage.html" target="_blank">local storage</a> instead. This is done by overriding <code>Backbone.World</code> methods <code>save</code> and <code>fetch</code>. See file <code>src/local-storage.js</code> for details.
          </p>
        </div>
      </div>

      <div id="performance" class="row">
        <div class="col-md-12">
          <h1>Performance and Debugging</h1>
          <p>
            HTML5 canvas has come a long way in terms on performance. Browser implementations of canvas now offer impressive performance. On mobile, Apple leads the pack being able to sustain a 60fps for the Super Mario Bros example. However on Android, frame rates drop fast to the 30s when the background needs to be redrawn. On Surface performance seems good on newer models, as slow as Android tablets on the first generation RT model.
          </p>
          <p>
            This being said, there are things you can do to ensure the best performance.
          </p>
          <h4>Keep cycle time below 16ms</h4>
          <p>
            That is the time you have between redraws, 60 times a second. The <code>Backbone.Engine</code> will report the frame rate (fps), and cycle time (ct) if you add and attach a <code>Debug.Panel</code>. Make sure to use it. If you see the fps go down, and the ct go up, then your <code>update</code> and <code>draw</code> times must be too long. You can time the <code>update</code> time to pinpoint the issue.
          </p>
          <h4>Play well with Javascript Garbage Collection</h4>
          <p>
            You can't avoid it. You will leak memory. Every call made by <code>requestAnimationFrame</code> creates a function scope. It does so 60 times a second and it will need to be garbage collected. The browser will pause to collect garbage.
          </p>
          <p>
            You can however control the leakage rate. Try to create objects upfront, and pool resources as much as possible. That's why sprite sheets are shared among sprites. If you ever see that your game jerks, at an even interval (i.e. every 30s), then you are probably being hit by the garbage collector.
          </p>
          <p>
            You can use the Timeline tool in Chrome/Safari Developer Tools to identify this. Record a session and once done, you can apply a filter <code>gc</code> to filter on garbage collection events. You will notice they are at evenly spaced intervals. On my machine, for Super Mario Bros, 3.5MB is collected every 4s on average. There is no jerk. I consider that healthy.
          </p>
          <p>
            Some further references and good resources on performance:
          </p>
          <ul>
            <li><a href="http://blog.artillery.com/2012/10/browser-garbage-collection-and-framerate.html" target="_blank">Browser Garbage Collection and Frame Rate</a></li>
            <li><a href="https://www.scirra.com/blog/76/how-to-write-low-garbage-real-time-javascript" target="_blank">How to write low garbage real-time Javascript</a></li>
            <li><a href="http://www.html5rocks.com/en/tutorials/canvas/performance/" target="_blank">Improving HTML5 Canvas Performance</a></li>
          </ul>
        </div>
      </div>

      <div id="publishing" class="row">
        <div class="col-md-12">
          <h1>Publishing your Game</h1>
          <p>
            If you forked this repo, your game is already published on the web on your Github page under <code>[username].github.io/backbone-game-engine</code>.
          </p>
          <p>
            If you own an iPad or iPhone, you can add it to the home screen as a Web app. It will open in full-screen and if you've implemented an Application Cache, it will work offline too.
          </p>
          <p>
            For publishing to the Apple App Store, or Google Play, you can use <a href="https://www.ludei.com/cocoonjs/" target="_blank">CocoonJS</a>. They claim to increase the canvas performance up to 10x (that's good because HTML5 canvas performance on Android is not great).
          </p>
          <p>
            If you use CocoonJS, ensure to follow their best practices. Notably, only use the canvas (there is only basic support for HTML). Backbone Game Engine was written canvas-first and without jQuery and DOM manipulations for this reason.
          </p>
        </div>
      </div>

      <div id="change-log" class="row">
        <div class="col-md-12">
          <h1>Change Log</h1>
          <h4>0.1 - 2014-05-19</h4>
          <p>
            Initial release.
          </p>
        </div>
      </div>

    </div>

    <div class="col-md-3">
      <div id="sidebar" class="bs-sidebar affix">
        <ul class="nav bs-sidenav">
          <li class="active"><a href="#introduction">Introduction</a></li>
          <li><a href="#getting-started">Getting Started</a></li>
          <li><a href="#documentation">Reference</a></li>
          <li><a href="#documentation-Engine">&nbsp;&nbsp;Backbone.Engine</a></li>
          <li><a href="#documentation-SpriteSheet">&nbsp;&nbsp;Backbone.SpriteSheet</a></li>
          <li><a href="#documentation-Sprite">&nbsp;&nbsp;Backbone.Sprite</a></li>
          <li><a href="#documentation-Input">&nbsp;&nbsp;Backbone.Input</a></li>
          <li><a href="#documentation-World">&nbsp;&nbsp;Backbone.World</a></li>
          <li><a href="#documentation-WorldEditor">&nbsp;&nbsp;Backbone.WorldEditor</a></li>
          <li><a href="#documentation-Hero">&nbsp;&nbsp;Backbone.Hero</a></li>
          <li><a href="#documentation-Camera">&nbsp;&nbsp;Backbone.Camera</a></li>
          <li><a href="#documentation-Clock">&nbsp;&nbsp;Backbone.Clock</a></li>
          <li><a href="#documentation-Button">&nbsp;&nbsp;Backbone.Button</a></li>
          <li><a href="#documentation-DebugPanel">&nbsp;&nbsp;Backbone.DebugPanel</a></li>
          <li><a href="#documentation-Shapes">&nbsp;&nbsp;Shape functions</a></li>
          <li><a href="#going-offline">Going Offline</a></li>
          <li><a href="#persistence">Persistence</a></li>
          <li><a href="#performance">Performance</a></li>
          <li><a href="#publishing">Publishing</a></li>
          <li><a href="#change-log">Change Log</a></li>
        </ul>
      </div>
    </div>

    </div>
    </div>
    <br/>

    <footer class="navbar navbar-default">
        <p class="navbar-text navbar-left">
          &copy; 2014 <a href="http://martindrapeau.tumblr.com/">Martin Drapeau.</a>
          <a href="https://github.com/martindrapeau/backbone-game-engine/blob/gh-pages/LICENSE">Licensed under MIT.</a>
        </p>
        <p class="navbar-text navbar-right">Written in Montréal, Canada.</p>
        <p class="navbar-text navbar-right">&nbsp;</p>
    </footer>
  </body>
</html>